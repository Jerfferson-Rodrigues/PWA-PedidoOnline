{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n/** Supported mask type */\n\n/** Append flags */\n\n/** Extract flags */\n\n/** Provides common masking stuff */\n\nclass Masked {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n  constructor(opts) {\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return; // $FlowFixMe\n\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n  /**\n    Sets new options\n    @protected\n  */\n\n\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n  /** Mask state */\n\n\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n\n  set state(state) {\n    this._value = state._value;\n  }\n  /** Resets value */\n\n\n  reset() {\n    this._value = '';\n  }\n  /** */\n\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this.resolve(value);\n  }\n  /** Resolve new value */\n\n\n  resolve(value) {\n    this.reset();\n    this.append(value, {\n      input: true\n    }, '');\n    this.doCommit();\n    return this.value;\n  }\n  /** */\n\n\n  get unmaskedValue() {\n    return this.value;\n  }\n\n  set unmaskedValue(value) {\n    this.reset();\n    this.append(value, {}, '');\n    this.doCommit();\n  }\n  /** */\n\n\n  get typedValue() {\n    return this.doParse(this.value);\n  }\n\n  set typedValue(value) {\n    this.value = this.doFormat(value);\n  }\n  /** Value that includes raw user input */\n\n\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n\n  set rawInputValue(value) {\n    this.reset();\n    this.append(value, {\n      raw: true\n    }, '');\n    this.doCommit();\n  }\n\n  get displayValue() {\n    return this.value;\n  }\n  /** */\n\n\n  get isComplete() {\n    return true;\n  }\n  /** */\n\n\n  get isFilled() {\n    return this.isComplete;\n  }\n  /** Finds nearest input position in direction */\n\n\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  /** Extracts value in range considering flags */\n\n\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return this.value.slice(fromPos, toPos);\n  }\n  /** Extracts tail in range */\n\n\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n  /** Appends tail */\n  // $FlowFixMe no ideas\n\n\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n  /** Appends char */\n\n\n  _appendCharRaw(ch) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n  /** Appends char */\n\n\n  _appendChar(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const consistentState = this.state;\n    let details;\n    [ch, details] = normalizePrepare(this.doPrepare(ch, flags));\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        } // if ok, rollback state after tail\n\n\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      } // revert all if something went wrong\n\n\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n\n    return details;\n  }\n  /** Appends optional placeholder at end */\n\n\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n  /** Appends optional eager placeholder at end */\n\n\n  _appendEager() {\n    return new ChangeDetails();\n  }\n  /** Appends symbols considering flags */\n  // $FlowFixMe no ideas\n\n\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const details = new ChangeDetails();\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;\n\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    } // append tail but aggregate only tailShift\n\n\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags !== null && flags !== void 0 && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n\n    return details;\n  }\n  /** */\n\n\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n  /** Calls function and reapplies current value */\n\n\n  withValueRefresh(fn) {\n    if (this._refreshing || !this.isInitialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput; // append lost trailing chars at end\n\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n\n    delete this._refreshing;\n    return ret;\n  }\n  /** */\n\n\n  runIsolated(fn) {\n    if (this._isolated || !this.isInitialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  /** */\n\n\n  doSkipInvalid(ch) {\n    return this.skipInvalid;\n  }\n  /**\n    Prepares string before mask processing\n    @protected\n  */\n\n\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.prepare ? this.prepare(str, this, flags) : str;\n  }\n  /**\n    Validates if value is acceptable\n    @protected\n  */\n\n\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n  /**\n    Does additional processing in the end of editing\n    @protected\n  */\n\n\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  /** */\n\n\n  doFormat(value) {\n    return this.format ? this.format(value, this) : value;\n  }\n  /** */\n\n\n  doParse(str) {\n    return this.parse ? this.parse(str, this) : str;\n  }\n  /** */\n\n\n  splice(start, deleteCount, inserted, removeDirection) {\n    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      input: true\n    };\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n\n    let startChangePos = start;\n    const details = new ChangeDetails(); // if it is just deletion without insertion\n\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection); // adjust tailShift if start was aligned\n\n      details.tailShift = startChangePos - start;\n    }\n\n    details.aggregate(this.remove(startChangePos));\n\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);\n  }\n\n}\n\nMasked.DEFAULTS = {\n  format: String,\n  parse: v => v,\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"names":["ChangeDetails","ContinuousTailDetails","isString","normalizePrepare","DIRECTION","forceDirection","IMask","Masked","constructor","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","updateOptions","keys","length","withValueRefresh","bind","state","value","reset","resolve","append","input","doCommit","unmaskedValue","typedValue","doParse","doFormat","rawInputValue","extractInput","raw","displayValue","isComplete","isFilled","nearestInputPos","cursorPos","direction","fromPos","arguments","undefined","toPos","slice","extractTail","appendTail","tail","String","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","flags","checkTail","consistentState","details","doPrepare","aggregate","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailShift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","ci","d","doSkipInvalid","eager","remove","fn","_refreshing","rawInput","ret","indexOf","runIsolated","_isolated","skipInvalid","prepare","validate","parent","commit","format","parse","splice","start","deleteCount","removeDirection","tailPos","eagerRemove","oldRawValue","startChangePos","NONE","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","typedValueEquals","tval","EMPTY_VALUES","includes","v","default"],"sources":["D:/React/PedidoOnline/node_modules/imask/esm/masked/base.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Append flags */\n\n/** Extract flags */\n\n/** Provides common masking stuff */\nclass Masked {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */ // $FlowFixMe no ideas\n  /** Transforms value before mask processing */\n  /** Validates if value is acceptable */\n  /** Does additional processing in the end of editing */\n  /** Format typed value to string */\n  /** Parse strgin to get typed value */\n  /** Enable characters overwriting */\n  /** */\n  /** */\n  /** */\n  constructor(opts) {\n    this._value = '';\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n    this.isInitialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    // $FlowFixMe\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /**\n    Sets new options\n    @protected\n  */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n\n  /** */\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value);\n  }\n\n  /** Resolve new value */\n  resolve(value) {\n    this.reset();\n    this.append(value, {\n      input: true\n    }, '');\n    this.doCommit();\n    return this.value;\n  }\n\n  /** */\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.reset();\n    this.append(value, {}, '');\n    this.doCommit();\n  }\n\n  /** */\n  get typedValue() {\n    return this.doParse(this.value);\n  }\n  set typedValue(value) {\n    this.value = this.doFormat(value);\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.value.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.reset();\n    this.append(value, {\n      raw: true\n    }, '');\n    this.doCommit();\n  }\n  get displayValue() {\n    return this.value;\n  }\n\n  /** */\n  get isComplete() {\n    return true;\n  }\n\n  /** */\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return this.value.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  // $FlowFixMe no ideas\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const consistentState = this.state;\n    let details;\n    [ch, details] = normalizePrepare(this.doPrepare(ch, flags));\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.value.length - details.tailShift);\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString();\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  // $FlowFixMe no ideas\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const details = new ChangeDetails();\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags !== null && flags !== void 0 && flags.tail) flags._beforeTailState = this.state;\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags !== null && flags !== void 0 && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n    return details;\n  }\n\n  /** */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this.isInitialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.value.length), {}, '');\n    }\n    delete this._refreshing;\n    return ret;\n  }\n\n  /** */\n  runIsolated(fn) {\n    if (this._isolated || !this.isInitialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n\n  /** */\n  doSkipInvalid(ch) {\n    return this.skipInvalid;\n  }\n\n  /**\n    Prepares string before mask processing\n    @protected\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.prepare ? this.prepare(str, this, flags) : str;\n  }\n\n  /**\n    Validates if value is acceptable\n    @protected\n  */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /**\n    Does additional processing in the end of editing\n    @protected\n  */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n\n  /** */\n  doFormat(value) {\n    return this.format ? this.format(value, this) : value;\n  }\n\n  /** */\n  doParse(str) {\n    return this.parse ? this.parse(str, this) : str;\n  }\n\n  /** */\n  splice(start, deleteCount, inserted, removeDirection) {\n    let flags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      input: true\n    };\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || this.doFormat(value) === this.doFormat(this.typedValue);\n  }\n}\nMasked.DEFAULTS = {\n  format: String,\n  parse: v => v,\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}