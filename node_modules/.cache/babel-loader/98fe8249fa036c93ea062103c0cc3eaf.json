{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n      _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\n\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n  /**\n    @override\n  */\n\n\n  _update(opts) {\n    super._update(opts);\n\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : []; // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n  /**\n    @override\n  */\n\n\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const details = this._applyDispatch(ch, flags);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n\n    return details;\n  }\n\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch\n\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n\n    return details;\n  }\n\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n\n    return details;\n  }\n  /**\n   @override\n  */\n\n\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n\n    return details;\n  }\n\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n  /**\n    @override\n  */\n\n\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.dispatch(appended, this, flags);\n  }\n  /**\n    @override\n  */\n\n\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  /**\n    @override\n  */\n\n\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n\n    return [s, details];\n  }\n  /**\n    @override\n  */\n\n\n  reset() {\n    var _this$currentMask;\n\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  /**\n    @override\n  */\n\n\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n\n  set value(value) {\n    super.value = value;\n  }\n  /**\n    @override\n  */\n\n\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  /**\n    @override\n  */\n\n\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  } // probably typedValue should not be used with dynamic\n\n\n  set typedValue(value) {\n    let unmaskedValue = String(value); // double check it\n\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n\n    this.unmaskedValue = unmaskedValue;\n  }\n\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  /**\n    @override\n  */\n\n\n  get isComplete() {\n    var _this$currentMask2;\n\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n  /**\n    @override\n  */\n\n\n  get isFilled() {\n    var _this$currentMask3;\n\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n  /**\n    @override\n  */\n\n\n  remove() {\n    const details = new ChangeDetails();\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments)) // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n\n    return details;\n  }\n  /**\n    @override\n  */\n\n\n  get state() {\n    var _this$currentMask4;\n\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask\n    } = state,\n          maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n\n    super.state = maskedState;\n  }\n  /**\n    @override\n  */\n\n\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n  /**\n    @override\n  */\n\n\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n  /**\n    @override\n  */\n\n\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  /**\n    @override\n  */\n\n\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n  /**\n    @override\n  */\n\n\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n\n      const _mask$mi = mask[mi],\n            {\n        mask: oldMask\n      } = _mask$mi,\n            restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n  /**\n    @override\n  */\n\n\n  typedValueEquals(value) {\n    var _this$currentMask5;\n\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n\n}\n\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue; // simulate input\n\n    const inputs = masked.compiledMasks.map((m, index) => {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, masked.currentMaskFlags(flags));\n      const weight = m.rawInputValue.length;\n      return {\n        weight,\n        index\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort((i1, i2) => i2.weight - i1.weight);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","normalizePrepare","objectIncludes","ChangeDetails","createMask","Masked","IMask","_excluded","_excluded2","MaskedDynamic","constructor","opts","Object","assign","DEFAULTS","currentMask","_update","compiledMasks","Array","isArray","mask","map","m","_appendCharRaw","ch","flags","arguments","length","undefined","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","prevValueBeforeTail","tail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","overwrite","console","warn","eager","skipInvalid","isInitialized","maskEquals","every","_mask$mi","oldMask","restOpts","typedValueEquals","_this$currentMask5","masked","inputs","index","weight","sort","i1","i2","default"],"sources":["D:/React/PedidoOnline/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags));\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.dispatch(appended, this, flags);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      m.reset();\n      m.append(inputValue, {\n        raw: true\n      });\n      m.append(appended, masked.currentMaskFlags(flags));\n      const weight = m.rawInputValue.length;\n      return {\n        weight,\n        index\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}