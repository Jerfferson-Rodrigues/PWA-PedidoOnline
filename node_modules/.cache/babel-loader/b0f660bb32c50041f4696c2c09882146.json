{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n/** Date mask */\n\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDate.DEFAULTS, opts));\n  }\n  /**\n    @override\n  */\n\n\n  _update(opts) {\n    if (opts.mask === Date) delete opts.mask;\n    if (opts.pattern) opts.mask = opts.pattern;\n    const blocks = opts.blocks;\n    opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block\n\n    if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n    if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n\n    if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n      opts.blocks.m.from = opts.min.getMonth() + 1;\n      opts.blocks.m.to = opts.max.getMonth() + 1;\n\n      if (opts.blocks.m.from === opts.blocks.m.to) {\n        opts.blocks.d.from = opts.min.getDate();\n        opts.blocks.d.to = opts.max.getDate();\n      }\n    }\n\n    Object.assign(opts.blocks, this.blocks, blocks); // add autofix\n\n    Object.keys(opts.blocks).forEach(bk => {\n      const b = opts.blocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n\n    super._update(opts);\n  }\n  /**\n    @override\n  */\n\n\n  doValidate() {\n    const date = this.date;\n    return super.doValidate(...arguments) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n  /** Checks if date is exists */\n\n\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n  /** Parsed Date */\n\n\n  get date() {\n    return this.typedValue;\n  }\n\n  set date(date) {\n    this.typedValue = date;\n  }\n  /**\n    @override\n  */\n\n\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n  /**\n    @override\n  */\n\n\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n\n}\n\nMaskedDate.DEFAULTS = {\n  pattern: 'd{.}`m{.}`Y',\n  format: date => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: str => {\n    const [day, month, year] = str.split('.');\n    return new Date(year, month - 1, day);\n  }\n};\n\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\n\nIMask.MaskedDate = MaskedDate;\nexport { MaskedDate as default };","map":{"version":3,"names":["MaskedPattern","MaskedRange","IMask","MaskedDate","constructor","opts","Object","assign","DEFAULTS","_update","mask","Date","pattern","blocks","GET_DEFAULT_BLOCKS","min","Y","from","getFullYear","max","to","m","getMonth","d","getDate","keys","forEach","bk","b","autofix","doValidate","date","arguments","isComplete","isDateExist","value","str","format","parse","indexOf","typedValue","maskEquals","day","String","padStart","month","year","join","split","maxLength","default"],"sources":["D:/React/PedidoOnline/node_modules/imask/esm/masked/date.js"],"sourcesContent":["import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDate.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    if (opts.mask === Date) delete opts.mask;\n    if (opts.pattern) opts.mask = opts.pattern;\n    const blocks = opts.blocks;\n    opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n    if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n      opts.blocks.m.from = opts.min.getMonth() + 1;\n      opts.blocks.m.to = opts.max.getMonth() + 1;\n      if (opts.blocks.m.from === opts.blocks.m.to) {\n        opts.blocks.d.from = opts.min.getDate();\n        opts.blocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(opts.blocks, this.blocks, blocks);\n\n    // add autofix\n    Object.keys(opts.blocks).forEach(bk => {\n      const b = opts.blocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const date = this.date;\n    return super.doValidate(...arguments) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n}\nMaskedDate.DEFAULTS = {\n  pattern: 'd{.}`m{.}`Y',\n  format: date => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: str => {\n    const [day, month, year] = str.split('.');\n    return new Date(year, month - 1, day);\n  }\n};\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nIMask.MaskedDate = MaskedDate;\n\nexport { MaskedDate as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}