{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"_blocks\"];\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\n\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\n    @override\n    @param {Object} opts\n  */\n\n\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n    super._update(opts);\n\n    this._rebuildMask();\n  }\n  /** */\n\n\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0); // order by key length\n\n        bNames.sort((a, b) => b.length - a.length); // use block name with max length\n\n        const bName = bNames[0];\n\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock); // store block index\n\n\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n\n          i += bName.length - 1;\n          continue;\n        }\n      }\n\n      let char = pattern[i];\n      let isInput = (char in defs);\n\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n\n        continue;\n      }\n\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n\n      this._blocks.push(def);\n    }\n  }\n  /**\n    @override\n  */\n\n\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n\n  set state(state) {\n    const {\n      _blocks\n    } = state,\n          maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n\n    super.state = maskedState;\n  }\n  /**\n    @override\n  */\n\n\n  reset() {\n    super.reset();\n\n    this._blocks.forEach(b => b.reset());\n  }\n  /**\n    @override\n  */\n\n\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n  /**\n    @override\n  */\n\n\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  /**\n    @override\n  */\n\n\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n\n    super.doCommit();\n  }\n  /**\n    @override\n  */\n\n\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  /**\n    @override\n  */\n\n\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n\n  set value(value) {\n    super.value = value;\n  }\n\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  /**\n    @override\n  */\n\n\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  /**\n    @override\n  */\n\n\n  _appendEager() {\n    var _this$_mapPosToBlock;\n\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n\n    return details;\n  }\n  /**\n    @override\n  */\n\n\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const blockIter = this._mapPosToBlock(this.value.length);\n\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n\n      const block = this._blocks[bi];\n      if (!block) break;\n\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  /**\n    @override\n  */\n\n\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n\n    return chunkTail;\n  }\n  /**\n    @override\n  */\n\n\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n\n    return input;\n  }\n\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n\n    return stopBefore;\n  }\n  /** Appends placeholder depending on laziness */\n\n\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n\n        const bDetails = b._appendPlaceholder(...args);\n\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n\n    return details;\n  }\n  /** Finds block in pos */\n\n\n  _mapPosToBlock(pos) {\n    let accVal = '';\n\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  /** */\n\n\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n  /** */\n\n\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        } // process last block\n\n\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  /**\n    @override\n  */\n\n\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n\n    return removeDetails;\n  }\n  /**\n    @override\n  */\n\n\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    } // FORCE is only about a|* otherwise is 0\n\n\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      } // forward flow\n\n\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled(); // backward flow\n\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos; // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n\n    return cursorPos;\n  }\n  /** Get block by name */\n\n\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n  /** Get all blocks by name */\n\n\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n\n}\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","constructor","opts","arguments","length","undefined","definitions","Object","assign","DEFAULTS","_update","_rebuildMask","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","_defs$char","_defs$char2","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","maskedBlock","parent","lazy","eager","placeholderChar","displayChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","maskOpts","prototype","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","value","displayValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","args","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["D:/React/PedidoOnline/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}